---
title: DDIA第五章-数据复制笔记
date: 2021-11-29 22:50:39
tags:
---
# DDIA第五章-数据复制 笔记

## 前言

多副本技术主要服务于以下目的：

> + 高可用性：即使某台机器出现故障，系统也能正常运行
>
> + 连接断开与容错：允许应用程序在出现网络中断时继续工作。
>
> + 低延迟：将数据放置在距离用户较劲的地方，从而实现更快地交互。
>
> + 可扩展性：采用多副本读取，大幅提高系统读操作的吞吐量。

本章主要讨论了三种多副本方案：主从复制、多主节点复制、无主节点复制。

本章主要讨论数据库实践中常用的、相对简单的复制技术，不涉及多副本一致性和共识。

## 主从复制

只能在主节点写，可以在所有节点读。

同步/异步复制

> + 同步复制：主节点等待确认其他从节点写入数据后才报告成功写入。
> + 异步复制：主节点写入后即返回写入成功。

### 复制日志的实现方式

#### 基于语句的复制

主节点将每个操作语句记录下来作为日志发给从节点。对于关系型数据库，就是发SQL。

不适用：

> + 任何调用非确定性函数的语句：如NOW()获取当前时间，RAND()获取随机数，可能在不同的副本上产生不同的值。主节点可以将非确定性函数替换为执行后的结果。
> + 语句中使用了自增列，或是依赖于数据库的现有数据（如UPDATE ... WHERE <某些条件>），则所有副本必须按照完全相同的顺序执行。进而，如果有并发执行的事务，会有很大限制。
> + 有副作用的语句（如，触发器、存储过程、用户定义的函数等），可能会在不同的副本上产生不同的副作用。

#### 基于write-ahead log传输

不管是日志结构存储引擎（LSM-Trees，log本来就是主要存储方式）还是采用覆盖写磁盘的B-Trees（WAL），都会有一个追加写的log。可以将该log发给从节点来构建副本。

缺点是log描述的数据结果非常底层：一个WAL包含了哪些磁盘块多哪些字节发生改变。这使得复制方案与存储引擎紧密耦合，要求主从节点的软件版本一致。

#### 基于行的逻辑日志复制

与WAL相对的，复制和存储引擎采取不同的日志格式，让复制和存储逻辑剥离。这种复制日志被称为逻辑日志，以区分物理存储引擎的数据表示。

对于关系数据库来说，逻辑日志通常是指一系列记录来描述数据表**行级别**的写请求。

> + 对于行插入，逻辑日志包含所有相关列的新值。
> + 对于行删除，逻辑日志里包含足够的信息来唯一标识已删除的行，通常是靠主键。
> + 对于行更新，逻辑日志里包含足够的信息来唯一标识更新的行，以及所有列的新值。

#### 基于触发器的复制

某些情况下，需要将复制控制交给应用程序层，如，只想复制数据的一部分，想从一种数据库复制到另一种数据库，需要订制、管理冲突解决逻辑。

触发器支持注册自己的应用层代码，使得当数据库系统发生数据更改（写事务）时自动执行自定义代码。

## 复制滞后导致的三个问题

异步复制会导致复制滞后，从而导致三个（本节主要介绍三个）问题：读自己的写、单调读、前缀一致读。

### 读自己的写(Reading Your Own Writes)

问题描述：应用层将数据写入主节点，由于异步复制，数据未到某从节点，应用层从该从节点读数据时就读不到自己刚写的数据。

对于这种情况，需要“写后读一致性”（read-after-write consistency)，也称“读写一致性”(read-your-writes consistency)。该机制保证如果用户重新加载页面，他们总是能看到自己最近提交的更新，但对其他用户没有任何保证。

基于主从复制的系统的可行方案：

> + 如果用户访问可能会被修改的内容，从主节点读取；否则，在从节点读取。这要求在查询之前就知道内容是否可能被修改。比如，用户的首页信息只能由所有者编辑，其他人无法编辑，因此可以制定规则：总是从主节点读取用户自己的首页信息数据。比如，跟踪最近更新的时间，如果更新后一分钟以内，则总是在主节点读取。
> + 客户端记录最近更新的时间戳，并附在读请求里。如果某从节点不够新，就换另一个节点。
> + 如果副本分布在多数据中心，则将请求路由到主节点所在的数据中心（因为这里的节点更快被同步）。

### 单调读（Monotonic Reads）

问题描述：连续两次读，第二次读的落后于第一次读。单调读一致性保证不会出现这种情况。

实现单调读的一种方式，确保同一用户总是从固定的副本读取。

### 前缀一致读（Consistent Prefix Reads）

对于一系列按照某个顺序发生的写请求，读取这些内容时也会按照当时写入的顺序。这是分片数据库出现的一个特殊问题。

一个解决方案是确保任何具有因果关系顺序的写入都交给一个分区来完成。

## 多主节点复制

多个主节点接受写入

适用场景

> + 多数据中心:每个数据中心内，采用常规的主从复制方案；在数据中心之间，多个主节点相互进行数据多交换、更新。
> + 离线客户端操作：离线状态下，本地设备相当于一个主节点数据库。在离线状态下的任何更改，会在下次上线后，与服务器和其他设备同步。从架构层面看，这相当于数据中心之间的多主复制，只不过是数据中心之间网络连接非常不可靠的极端情况。
> + 协作编辑：多个用户同时编辑文档。当一个用户编辑时，所做的更改会立即应用到本地副本，然后异步复制到服务器以及编辑统一文档的其他用户。

### 处理写冲突

多主复制的最大问题就是可能发生写冲突，必须有解决冲突的方案。

收敛于一致状态：所有的复制模型至少应该确保数据在所有副本中最终状态是一致的。因此，数据库必须以一种收敛趋同的方式解决冲突。实现收敛的冲突解决有以下可能的方式：

> + 给每个写入分配一个唯一的ID，制定规则选出胜利者，并丢弃其他写入。会造成数据丢失。
> + 给每个副本分配一个唯一的ID，并制定规则，例如ID大的副本写入始终优先于ID小的副本。会造成数据丢失。
> + 以某种方式将这些值合并在一起。
> + 记录和保留冲突相关的所有信息，然后依靠应用层的逻辑，事后解决冲突。

## 无主节点复制

允许任何副本直接接受写请求。

### Quorum

n个副本，写入需要w个节点确认，读取需要至少查询r个节点，如果 w+r>n，则读取的节点中可以保证包含最新值。

#### quorum的局限性

> + 如果采用了sloppy quorum，则不能保证读到最新值。
> + 如果两个写操作同时进行，无法明确先后顺序。需要合并写入并发。
> + 如果写与读并发，写操作可能仅在部分副本完成，此时读到的是新值还是旧值存在不确定性。
> + 如果某些副本上写成功，某些副本上写入失败，总的成功副本少于w，那些成功的副本不会回滚，后续的读操作可能会读到不该读到的新值。
> + 如果具有新值的节点失效，且后续恢复时数据来自某旧值节点，则新值数量少于w，打破了w+r>n。
> + 即使一切工作正常，也会出现一些边界情况，详情见第9章。

quorum通常无法得到本章罗列的一致性保证，包括写后读、单调读、前缀一致读等。

#### sloppy quorum

当出现网络问题时，无法满足w和r的数量。可以将写请求暂时放在不属于n集合的其他临时节点中，令写和读满足w和r。等网络问题解决，再将临时节点中的数据回传给原始节点。sloppy quorum是为了提高写入的可用性，但也意味着即使满足w+r>n，也不能保证读取到新值，因为新值可能存在于临时节点，还没被回传过来。

### 检测并发写（处理写冲突）

#### 最后写入者获胜（last write wins，LWW）

为每个写请求附加一个时间戳，选择最新的时间戳，丢弃较早时间戳的写入。LWW会删除非并发写（因为时钟同步问题，第8章）。

#### 版本矢量

DDIA讲得太少了，有空补一下。
