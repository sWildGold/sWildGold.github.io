<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Hexo</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/sWildGold"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-LinuxIO"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/24/LinuxIO/"
    >Linux I/O</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/24/LinuxIO/" class="article-date">
  <time datetime="2022-02-24T15:46:54.000Z" itemprop="datePublished">2022-02-24</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Linux-I-O"><a href="#Linux-I-O" class="headerlink" title="Linux I/O"></a>Linux I/O</h1><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83398714">https://zhuanlan.zhihu.com/p/83398714</a></p>
<h2 id="同步-异步-阻塞-非阻塞"><a href="#同步-异步-阻塞-非阻塞" class="headerlink" title="同步/异步 阻塞/非阻塞"></a>同步/异步 阻塞/非阻塞</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gui951753/article/details/82345237">https://blog.csdn.net/gui951753/article/details/82345237</a><br><img src="https://pic2.zhimg.com/80/v2-3558db9949833f761428fc4293d03b7a_1440w.jpg?source=1940ef5c"></p>
<h2 id="5种-I-O-模型"><a href="#5种-I-O-模型" class="headerlink" title="5种 I/O 模型"></a>5种 I/O 模型</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/382972191/answer/1113293711">https://www.zhihu.com/question/382972191/answer/1113293711</a></p>
<h3 id="同步阻塞I-O-BIO"><a href="#同步阻塞I-O-BIO" class="headerlink" title="同步阻塞I/O(BIO)"></a>同步阻塞I/O(BIO)</h3><p><img src="https://pica.zhimg.com/80/v2-6f1d558d41f48a0f0c019511741941be_1440w.jpg?source=1940ef5c"></p>
<h3 id="非阻塞I-O-NIO"><a href="#非阻塞I-O-NIO" class="headerlink" title="非阻塞I/O(NIO)"></a>非阻塞I/O(NIO)</h3><h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p><img src="https://pic1.zhimg.com/80/v2-4fc213585997579bb20c1a3d54aac9df_1440w.jpg?source=1940ef5c"></p>
<h3 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h3><p><img src="https://pica.zhimg.com/80/v2-f7f7c7971942950ca13bd65391eac7f4_1440w.jpg?source=1940ef5c"></p>
<h3 id="异步非阻塞IO（AIO）"><a href="#异步非阻塞IO（AIO）" class="headerlink" title="异步非阻塞IO（AIO）"></a>异步非阻塞IO（AIO）</h3><p>首先AIO是异步的, 且是非阻塞的. 相较于前几种IO模型的最大的区别，在于其在IO处理过程中的第二步：此模型将第二步（处理已就绪数据）一并交给内核处理。在所有事情做完后告知用户进程（信号或者回调函数）</p>
<p><img src="https://pic1.zhimg.com/80/v2-f250f000fbca929da108eef38d79acbf_1440w.jpg?source=1940ef5c"></p>
<h3 id="高性能网络I-O实现"><a href="#高性能网络I-O实现" class="headerlink" title="高性能网络I/O实现"></a>高性能网络I/O实现</h3><p><img src="https://pica.zhimg.com/80/v2-2f368efeac0605943f5bc31693f82903_1440w.jpg?source=1940ef5c"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-八股文"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/22/%E5%85%AB%E8%82%A1%E6%96%87/"
    >八股文</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/22/%E5%85%AB%E8%82%A1%E6%96%87/" class="article-date">
  <time datetime="2022-02-22T15:46:54.000Z" itemprop="datePublished">2022-02-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="TCP-IP-五层模型-和-OSI-七层模型"><a href="#TCP-IP-五层模型-和-OSI-七层模型" class="headerlink" title="TCP/IP 五层模型 和 OSI 七层模型"></a>TCP/IP 五层模型 和 OSI 七层模型</h3><p>TCP/IP网络模型总共有五层</p>
<p>1.<strong>应用层</strong>:我们能接触到的就是应用层了，手机，电脑这些这些设备都属于应用层。<br>2.<strong>传输层</strong>:就是<strong>为应用层提供网络支持</strong>的，当设备作为接收⽅时，传输层则要负责把数据包传给应⽤，但是⼀台设备上可能会有很多应⽤在接收或者传输数据，因此需要⽤⼀个编号将应⽤区分开来，这个编号就是端⼝。所以 TCP 和 UDP 协议就是在这一层的<br>3.<strong>网络层</strong>:是<strong>负责传输数据</strong>的，最常使用的 ip 协议就在该层，⽹络层负责将数据从⼀个设备传输到另⼀个设备，世界上有很多设备，⽹络层需要有区分设备的编号。我们⼀般⽤ IP 地址给设备进⾏编号<br>4.<strong>数据链路层</strong>:每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。路由器就是通过数据链路层来知道这个 ip 地址是属于哪个设备的，它主要<strong>为⽹络层提供链路级别传输的服务</strong>。<br>5.<strong>物理层</strong>:当数据准备要从设备发送到⽹络的时候，需要把数据包转换成电信号，让其可以在物理介质中传输，它主要是<strong>为数据链路层提供⼆进制传输的服务</strong>。</p>
<p>OSI七层模型：</p>
<p>应用层-&gt; 应用层、表示层、会话层</p>
<p>表示层：数据格式化，加密、解密。对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文进行解压缩，对加密文件进行解密等。</p>
<p>会话层：建立、维护、管理会话连接。</p>
<p>###TCP 建立连接的过程是怎样的？</p>
<p><img src="https://filescdn.proginn.com/27cfff9a248b772309520ecae9af28c3/89e131cbf0bb238770808e7209140ce8.webp"></p>
<p>第一次握手:A 的 TCP 进程创建一个 传输控制块 TCB ，然后向 B 发出连接请求报文段。之后将同步位 <strong>SYN 设置为 1</strong>，同时选择一个初始序列号 <strong>seq=x</strong>，这时客户端 A 进入到 <strong>SYN-SENT（同步已发送）</strong>状态。<br>第二次握手:B 收到连接请求报文段，如果同意建立连接，则向 A 发送确认。在确认报文段中 <strong>同步位 SYN=1、确认位 ACK=1、确认号 ack=x+1</strong>，同时也为自己选择一个初始序列号 <strong>seq=y</strong>，这时服务器 B 进入 SYN-RCVID 状态。<br>第三次握手:A 收到 B 的确认以后，再向 B 发出确认。确认报文 <strong>ACK=1、确认号ack=y+1</strong>。这时A进入到 ESTAB-LISHED 状态。<strong>当B接收到A的确认后，也进入 ESTAB-LISHED</strong> 状态。连接建立完成</p>
<p>为什么需要三次握手？</p>
<p>三次握⼿就已经是理论上<strong>建立可靠连接</strong>的最小次数了，所以不需要更多的连接</p>
<h3 id="TCP断开连接的过程"><a href="#TCP断开连接的过程" class="headerlink" title="TCP断开连接的过程"></a>TCP断开连接的过程</h3><p><img src="https://filescdn.proginn.com/aaca88541c9dbd7358ddc910abf4d8ef/3db74420e3b61e74ccf24b1ff9eb2a7b.webp"></p>
<p>第一次挥手:A 先发送连接释放报文段，段首部的终止控制位 <strong>FIN=1</strong>，序号<strong>seq=u</strong>（等于<strong>A前面发送数据的最后一个序号加1</strong>）；然后 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。</p>
<p>第二次挥手:B 收到 A 的连接释放报文段后，立刻发出确认报文段，确认号 <strong>ack=u+1</strong>，序号 <strong>seq=v</strong>（等于 <strong>B 前面发送数据的最后一个序号加1</strong>）；然后 B 进入 CLOSE-WAIT（关闭等待）状态。</p>
<p>第三次挥手:A 收到 B 的确认报文段后进入到 <strong>FIN-WAIT-2</strong>（终止等待2）状态，继续等待 B 发出连接释放报文段；</p>
<p>若 B 已经没有数据要发送，B 就会向 A 发送连接释放报文段，段首部的终止控制位 <strong>FIN=1</strong>，序号 <strong>seq=w</strong>（半关闭状态可能又发送了一些数据），确认号 <strong>ack=u+1</strong>，这时B进入 <strong>LAST-ACK</strong>（最后确认）状态，等待A的确认。<br>第四次挥手:A收到B的连接释放报文段并发出确认，确认段中 确认位 <strong>ACK=1</strong>，确认号 <strong>ack=w+1</strong>，序号 <strong>seq=u+1</strong>；然后 A 进入到<strong>TIME-WAIT</strong>（时间等待）状态。当 B 再接收到该确认段后，B 就进入 <strong>CLOSED</strong>状态。</p>
<p>为什么是四次挥手</p>
<p>因为 tcp 可以在发送数据的同时也能接受数据，要实现可靠的连接关闭，A 发出结束报文 FIN，收到 B 确认后 A 知道自己没有数据需要发送了，B 知道 A 不再发送数据了，自己也不会接收数据了，<strong>但是此时 A 还是可以接收数据，B 也可以发送数据</strong>；当 B 发出 FIN 报文的时候此时两边才会真正的断开连接，读写分开。</p>
<h3 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaolincoding/p/12732052.html">https://www.cnblogs.com/xiaolincoding/p/12732052.html</a><br>TCP 是<strong>每发送⼀个数据，都要进⾏⼀次确认应答</strong>。只有上一个收到了回应才发送下一个，这样<strong>效率会非常低</strong>，因此<strong>引进了滑动窗口</strong>的概念.</p>
<p>其实就是在发送方<strong>设立一个缓存区间</strong>，将已发送但未收到确认的消息<strong>缓存</strong>起来，<strong>假如一个窗口可以发送 5 个 TCP 段</strong>，那么发送方就可以连续发送 5 个 TCP 段，然后就会将这 5 个 TCP 段的数据缓存起来，这 5 个 TCP 段是有序的，只要后面的消息收到了 ACK ，那么不管前面的是否有收到 ACK,都代表成功，<strong>窗⼝⼤⼩是由接收方决定的</strong>。</p>
<p>窗⼝⼤⼩就是指<strong>不需要等待应答，还可以发送数据的大小</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%AB%E8%82%A1/" rel="tag">八股</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Paxos笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/28/Paxos%E7%AC%94%E8%AE%B0/"
    >Paxos 笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/28/Paxos%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2022-01-28T14:46:54.000Z" itemprop="datePublished">2022-01-28</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Paxos-笔记"><a href="#Paxos-笔记" class="headerlink" title="Paxos 笔记"></a>Paxos 笔记</h1><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36648084/answer/82332860">raft和paxos比较 作者：朱一聪</a></p>
<h2 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic-Paxos"></a>Basic-Paxos</h2><p>参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31780743">Paxos算法详解 作者：祥光</a></li>
<li><a target="_blank" rel="noopener" href="https://ying-zhang.github.io/dist/2001-paxos_made_simple-cn/">paxos made simple译文 作者：张营</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/258929773">PAXOS Paxos Made Simp阅读笔记 作者：不想说</a></li>
<li><a target="_blank" rel="noopener" href="http://oceanbase.org.cn/?p=90">[Paxos三部曲之一] 使用Basic-Paxos协议的日志同步与恢复 作者：郁白</a></li>
</ul>
<p>Paxos算法通过一个决议分为两个阶段（Learn阶段之前决议已经形成）：</p>
<ul>
<li>第一阶段：Prepare阶段。Proposer向Acceptors发出Prepare请求，Acceptors针对收到的Prepare请求进行Promise承诺。</li>
<li>第二阶段：Accept阶段。Proposer收到多数Acceptors承诺的Promise后，向Acceptors发出Propose请求，Acceptors针对收到的Propose请求进行Accept处理。</li>
<li>第三阶段：Learn阶段。Proposer在收到多数Acceptors的Accept之后，标志着本次Accept成功，决议形成，将形成的决议发送给所有Learners。</li>
</ul>
<p>Paxos算法流程中的每条消息描述如下：</p>
<p><strong>Prepare</strong>: Proposer生成全局唯一且递增的Proposal ID (可使用时间戳加Server ID)，向所有Acceptors发送Prepare请求，这里无需携带提案内容，只携带Proposal ID即可。<br><strong>Promise</strong>: Acceptors收到Prepare请求后，做出“两个承诺，一个应答”。<br>两个承诺：</p>
<ol>
<li><p>不再接受Proposal ID小于等于（注意：这里是&lt;= ）当前请求的Prepare请求。</p>
</li>
<li><p>不再接受Proposal ID小于（注意：这里是&lt; ）当前请求的Propose请求。</p>
</li>
</ol>
<p>一个应答：</p>
<p>不违背以前作出的承诺下，回复已经Accept过的提案中Proposal ID最大的那个提案的Value和Proposal ID，没有则返回空值。</p>
<p><strong>Propose</strong>: Proposer 收到多数Acceptors的Promise应答后，从应答中选择Proposal ID最大的提案的Value，作为本次要发起的提案。如果所有应答的提案Value均为空值，则可以自己随意决定提案Value。然后携带当前Proposal ID，向所有Acceptors发送Propose请求。</p>
<p><strong>Accept</strong>: Acceptor收到Propose请求后，在不违背自己之前作出的承诺下，接受并持久化当前Proposal ID和提案Value。<br>Learn: Proposer收到多数Acceptors的Accept后，决议形成，将形成的决议发送给所有Learners。</p>
<p>Paxos算法伪代码描述如下：</p>
<p><img src="https://pic2.zhimg.com/80/v2-8d4eaf5fdeb145e8bdf5e3bb1af408c9_1440w.jpg" alt="basic_paxos_Pseudocode"></p>
<ol>
<li>获取一个Proposal ID n，为了保证Proposal ID唯一，可采用时间戳+Server ID生成；(其实不需要唯一，见下方讨论)</li>
<li>Proposer向所有Acceptors广播Prepare(n)请求；</li>
<li>Acceptor比较n和minProposal，如果n&gt;minProposal，minProposal=n，并且将 acceptedProposal 和 acceptedValue 返回；</li>
<li>Proposer接收到过半数回复后，如果发现有acceptedValue返回，将所有回复中acceptedProposal最大的acceptedValue作为本次提案的value，否则可以任意决定本次提案的value；</li>
<li>到这里可以进入第二阶段，广播Accept (n,value) 到所有节点；</li>
<li>Acceptor比较n和minProposal，如果n&gt;=minProposal，则acceptedProposal=minProposal=n，acceptedValue=value，本地持久化后，返回；否则，返回minProposal。</li>
<li>提议者接收到过半数请求后，如果发现有返回值result &gt;n，表示有更新的提议，跳转到1；否则value达成一致。</li>
</ol>
<p>值得注意的点：</p>
<ol>
<li>paxos有活锁问题吗，怎么解决？<ul>
<li>有。两个Proposer因为自己的Proposal ID过低，不断增加ID，你编号高，我再比你更高，反复如此，算法永远无法结束。</li>
<li>解决方法：multi-paxos通过选举出一个Proposer作Leader，所有的Proposal都通过Leader来提交，解决了大部分的冲突问题。Leader选举时产生冲突怎么办？参考raft，每次prepare后失败，随机等待一段时间。</li>
</ul>
</li>
<li>Proposal ID需要全局唯一吗？<ul>
<li>首先：<strong>paxos要求propose阶段的id是全局唯一，但不要求prepare阶段的id全局唯一</strong>。<br>首先是原文，“All that remains is to describe the mechanism for guaranteeing that no two proposals are ever issued with the same number.”<br>其中的关键词是“proposal”以及“issued”。一个proposer只有在进入accept阶段之后才可以“issue a proposal”，换句话讲，lamport根本没有要求过proposer在prepare阶段发出的id要全局唯一。<br>应该保证acceptor接收到proposal的时候，number是唯一的，但这显然和prepare阶段没有关系。<br>当然，最显而易见的方式，就是在prepare阶段的时候就保证prepare id唯一，然后由于accept阶段时的proposal id就是成功后的prepare id，那么proposal id就自然符合条件了，但这是充分非必要的。</li>
<li>prepare阶段id重复<strong>不会</strong>传递到propose阶段，条件是Acceptor在<strong>promise</strong>时<strong>拒绝</strong>小于<strong>等于</strong>当前持久化的minProposal。<br>分析：如果一个proposer1想要发起phase2 with number n，那么他需要获得majority的phase1的结果。<br>如果另一个proposer2想要发起phase2 with number n，他也需要获得majority的phase1的结果。<br>这两个majority一定有交集，交集中的acceptor不可能同时接受proposer1和proposer2的prepare request：因为phase1b只允许他答应其中一个。<br>因此这两个proposer在phase2发出的proposal不可能具有相同的n，因此paxos一开始的number全局唯一number是不必要的，只需要每个proposer本地的number唯一就好。</li>
<li>这里容易混淆的地方是很多文章写的是prepare阶段拒绝小于minProposal的请求（也就是接受n==minProposal的请求）。如果这样的话，就需要全局唯一的Proposal ID了。</li>
<li>怎样获得全局唯一的Proposal ID？<ul>
<li>物理时间戳：存疑。物理时间可能回调，导致生成两个相同的时间戳，全局不唯一</li>
<li>本地递增自然数+ip：即使前面重复了，ip也能确保不重复</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi-Paxos"></a>Multi-Paxos</h2><p>参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20417442">[Paxos三部曲之二] 使用Multi-Paxos协议的日志同步与恢复 作者：郁白</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20742144">[Paxos三部曲之三] Paxos成员组变更 作者：郁白</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/foxmailed/p/5487533.html">使用multi-paxos实现日志同步应用 作者：吴镝</a></li>
</ul>
<p>在Paxos集群中利用Paxos协议选举唯一的leader，只有leader能够propose日志,这样，prepare阶段就不会存在冲突，相当于对整个log文件做了一次prepare，后面这些日志都可以选用同一个proposal id.这样的话，每条日志只需要一次网络交互就能达成一致。回顾一下文章开头提到paxos中需要每个成员需要记录3个值，minProposal，acceptedProposal,acceptedValue，其中后面两个值可以直接记录在log中，而第一个值minProposal可以单独存在一个文件中。由于这里后面的日志都可以选用同一个proposal id，显然，在大部分时间内，minProposal都不需要改变。这正是multi-paxos的精髓。</p>
<h3 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h3><p>对于paxos来说，主的身份无所谓，主不需要像raft那样拥有最全的已经commit的日志。所以选主算法无所谓，比如大家都给机器ip最大的机器投票，或者给日志最多的投票，或者干脆直接运行一次paxos。</p>
<p>在Multi-Paxos中，我们将leader Elect过程中的prepare操作，视为对leader任期内将要写的所有日志的一次性prepare操作，在leader任期内投票的所有日志将携带有相同的proposalID。需要强调的是，为了遵守Basic-Paxos协议约束，在leader Elect的prepare阶段，acceptor应答prepare成功的消息之前要先将这次prepare请求所携带的proposalID持久化到本地。</p>
<p>对于leader Elect过程，我们并不关心leader Elect提案和决议的具体内容，因为无论执行多少次leader Elect，从Basic-Paxos的角度来看，都是同一个Paxos Instance在对已经形成的决议反复进行投票而已。而执行leader Elect这个过程，我们最关注的是要得到最近一次形成决议的proposer是谁，以及它的proposalID。在leader Elect过程中，得到多数派accept的proposer将成为leader，而它本次所用的proposalID即成为它任期内对所有日志（包括新增日志和后文将提到的重确认日志）进行投票时将要使用的proposalID（称为leader ProposalID）。</p>
<p>这里还需要考虑的一个问题是，由于多个server并发执行leader Elect，可能出现两个server在相近的时间内，先后执行leader Elect都成功，都认为自己是leader的情况。因此，当选leader在开始以leader身份提供服务之前，要使用leader ProposalID写一条日志（称为StartWorking日志），得到多数派确认后，再开始提供服务。这是因为根据Basic-Paxos的约束，可以推断出：先执行leader Elect成功的leader（称为L1），它的proposalID（称为P1）一定会小于后执行leader Elect成功的leader（称为L2）的proposalID（称为P2），而经过了两轮leader Elect，机群内多数派持久化的proposalID一定是P2，而此时L1使用P1执行accept时，由于P1 &lt; P2，它将无法得到机群内多数派的accept。</p>
<p>PhxPaxos两篇关于leader和Master的文章：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21466932">Paxos理论介绍(2): Multi-Paxos与Leader</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21540239">Paxos理论介绍(3): Master选举</a></p>
<h3 id="Confirm日志的优化"><a href="#Confirm日志的优化" class="headerlink" title="Confirm日志的优化"></a>Confirm日志的优化</h3><p>在Paxos协议中，对于决议的读取也是需要执行一轮Paxos过程的，在实际工程中做数据恢复时，对每条日志都执行一轮Paxos的代价过大，因此引入需要引入一种被成为confirm的机制，即leader持久化一条日志，得到多数派的accept后，就再写一条针对这条日志的confirm日志，表示这条日志已经确认形成了多数派备份，在回放日志时，判断如果一条日志有对应的confirm日志，则可以直接读取本地内容，而不需要再执行一轮Paxos。confirm日志只要写本地即可，不需要同步到备机，但是出于提示备机及时回放收到日志的考虑（备机收到一条日志后并不能立即回放，需要确认这条日志已经形成多数派备份才能回放），leader也会批量的给备机同步confirm日志。出于性能的考虑，confirm日志往往是延迟的成批写出去，因此仍然会出现部分日志已经形成多数派备份，但是没有对应的confirm日志的情况，对于这些日志，需要在恢复过程中进行重确认。</p>
<p>在实际的工程实践中，可以使用基于logID的滑动窗口机制来限制confirm日志与对应的原始日志的距离，以简化日志回放与查询逻辑。</p>
<h3 id="新任leader对日志的重确认"><a href="#新任leader对日志的重确认" class="headerlink" title="新任leader对日志的重确认"></a>新任leader对日志的重确认</h3><p>如上一节所述，在恢复过程中，拥有对应confirm日志的原始日志，可以被直接回放。而没有对应confirm日志的原始日志，则需要执行一轮Paxos，这个过程被成为重确认。</p>
<p>此外日志中的“空洞”，也需要进行重确认，因为当前leader再上一任leader的任期内可能错过了一些日志的同步，而这些日志在其他机器上形成多了多数派。由于logID连续递增，被错过的日志就成了连续logID连续递增序列中的“空洞”，需要通过重确认来补全这些“空洞”位置的日志。</p>
<p>新任leader在开始执行重确认前，需要先知道重确认的结束位置，因为leader本地相对于集群内多数派可能已经落后很多日志，所以需要想集群内其他server发送请求，查询每个server本地的最大logID，并从多数派的应答中选择最大的logID作为重确认的结束位置。也即开始提供服务后写日志的起始logID-1。</p>
<p>对于每条日志的重确认，需要执行一轮完整的Paxos过程，可能有些日志在恢复前确实未形成多数派备份，需要通过重新执行Paxos来把这些日志重新持久化才能回放。这种不管日志是否曾经形成多数派备份，都重新尝试持久化的原则，我们称之为“最大commit原则”。之所以要遵守“最大commit原则”，是因为我们无法区分出来未形成多数派备份的日志，而这些日志在上一任leader任期内，也必然是“未决”状态，尚未应答客户端，所以无论如何都重新持久化都是安全的。比如A/B/C三个server，一条日志在A/B上持久化成功，已经形成多数派，然后B宕机；另一种情况，A/B/C三个server，一条日志只在A上持久化成功，超时未形成多数派，然后B宕机。上述两种情况，最终的状态都是A上有一条日志，C上没有，在恢复时无法区分这条日志是否曾经形成过多数派，因此干脆按照“最大commit原则”将这条日志尝试重新在A/C上持久化后再回放。</p>
<p>需要注意的是，重确认日志时，要使用当前的leader ProposalID作为Paxos协议中的proposalID来对日志执行Paxos过程。因此在回放日志时，对于logID相同的多条日志，要以proposalID最大的为准。</p>
<h3 id="“幽灵复现”日志的处理"><a href="#“幽灵复现”日志的处理" class="headerlink" title="“幽灵复现”日志的处理"></a>“幽灵复现”日志的处理</h3><p>使用Paxos协议处理日志的备份与恢复，可以保证确认形成多数派的日志不丢失，但是无法避免一种被称为“幽灵复现”的现象，如下图所示：</p>
<p><img src="https://pic1.zhimg.com/80/f3053bc5ba559a0d4dda0d951d3ef85c_1440w.png" alt="幽灵复现"></p>
<ol>
<li><p>第一轮中A被选为Leader，写下了1-10号日志，其中1-5号日志形成了多数派，并且已给客户端应答，而对于6-10号日志，客户端超时未能得到应答。</p>
</li>
<li><p>第二轮，A宕机，B被选为Leader，由于B和C的最大的logID都是5，因此B不会去重确认6-10号日志，而是从6开始写新的日志，此时如果客户端来查询的话，是查询不到6-10号日志内容的，此后第二轮又写入了6-20号日志，但是只有6号和20号日志在多数派上持久化成功。</p>
</li>
<li><p>第三轮，A又被选为Leader，从多数派中可以得到最大logID为20，因此要将7-20号日志执行重确认，其中就包括了A上的7-10号日志，之后客户端再来查询的话，会发现上次查询不到的7-10号日志又像幽灵一样重新出现了。</p>
</li>
</ol>
<p>对于将Paxos协议应用在数据库日志同步场景的情况，“幽灵复现”问题是不可接受，一个简单的例子就是转账场景，用户转账时如果返回结果超时，那么往往会查询一下转账是否成功，来决定是否重试一下。如果第一次查询转账结果时，发现未生效而重试，而转账事务日志作为幽灵复现日志重新出现的话，就造成了用户重复转账。</p>
<p>为了处理“幽灵复现”问题，我们在每条日志的内容中保存一个generateID，leader在生成这条日志时以当前的leader ProposalID作为generateID。按logID顺序回放日志时，因为leader在开始服务之前一定会写一条StartWorking日志，所以如果出现generateID相对前一条日志变小的情况，说明这是一条“幽灵复现”日志（它的generateID会小于StartWorking日志），要忽略掉这条日志。</p>
<p>幽灵复现问题只会出现在持久化的log后的leader未与majority达成一致的尾巴部分，不会出现在空洞部分。因为第二阶段的leader重确认时会将空洞补上，但不会将尾巴补上。</p>
<p>raft同样存在幽灵复现问题，通过no-op机制解决。本质上no-op和startWorking日志是一样的。</p>
<p><a target="_blank" rel="noopener" href="http://blog.kongfy.com/2018/09/paxos_ghost_log/">Paxos与“幽灵复现”</a></p>
<h2 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/359206808">Raft成员变更的工程实践</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/420278350">Joint Consensus两阶段成员变更的单步实现</a></p>
<p>why?<br>成员变更也是一个一致性问题，即所有节点对新成员达成一致。但是成员变更又有其特殊性，因为在成员变更的过程中，参与投票的成员会发生变化。</p>
<p>如果将成员变更当成一般的一致性问题，直接向Leader节点发送成员变更请求，Leader同步成员变更日志，达成多数派之后提交，各节点提交成员变更日志后从旧成员配置（Cold）切换到新成员配置（Cnew）。</p>
<p>因为各个节点提交成员变更日志的时刻可能不同，造成各个节点从旧成员配置（Cold）切换到新成员配置（Cnew）的时刻不同。可能在某一时刻出现Cold和Cnew中同时存在两个不相交的多数派，进而可能选出两个Leader，形成不同的决议，破坏安全性。</p>
<h3 id="Joint-Consensus-两阶段"><a href="#Joint-Consensus-两阶段" class="headerlink" title="Joint Consensus(两阶段)"></a>Joint Consensus(两阶段)</h3><p>Leader收到成员变更请求后，先向Cold和Cnew同步一条Cold,new日志，此后所有日志都需要Cold和Cnew两个多数派的确认。Cold,new日志在Cold和Cnew都达成多数派之后才能提交，此后Leader再向Cold和Cnew同步一条只包含Cnew的日志，此后日志只需要Cnew的多数派确认。Cnew日志只需要在Cnew达成多数派即可提交，此时成员变更完成，不在Cnew中的成员自动下线。</p>
<p>注意点：<br>1、 Cold,new需要在Cold和Cnew两个集群取得多数派确认。<br>2、 不管是什么节点，只要新的配置写入它的log，它就用最新的。</p>
<h3 id="单步成员变更"><a href="#单步成员变更" class="headerlink" title="单步成员变更"></a>单步成员变更</h3><p>增加或删除一个成员时的情形，如图3所示，可以从数学上严格证明，只要每次只允许增加或删除一个成员，Cold与Cnew不可能形成两个不相交的多数派。因此只要每次只增加或删除一个成员，从Cold可直接切换到Cnew，无需过渡成员配置，实现单步成员变更。</p>
<p>raft单步变更有bug</p>
<p><img src="https://pic1.zhimg.com/80/v2-f40dd27f1d49bd9c1c00ddb939b7e534_1440w.jpg"></p>
<p>t₀：节点abcd的成员配置为C₀；</p>
<p>t₁：节点abcd在Term 0选出a为Leader，b和c为Follower；</p>
<p>t₂：节点a同步成员变更日志Cᵤ，只同步到a和u，未成功提交；</p>
<p>t₃：节点a宕机；</p>
<p>t₄：节点d在Term 1被选为Leader，b和c为Follower；</p>
<p>t₅：节点d同步成员变更日志Cᵥ，同步到c、d、v，成功提交；</p>
<p>t₆：节点d同步普通日志E，同步到c、d、v，成功提交；</p>
<p>t₇：节点d宕机；</p>
<p>t₈：节点a在Term 2重新选为Leader，u和b为Follower;</p>
<p>t₉：节点a同步本地的日志Cᵤ给所有人，造成已提交的Cᵥ和E丢失。</p>
<p>为什么会出现这样的问题呢？根本原因是上一任Leader的成员变更日志还没有同步到多数派就宕机了，新Leader一上任就进行成员变更，使用新的成员配置提交日志，之前上一任Leader重新上任之后可能形成另外一个多数派集合，产生脑裂，将已提交的日志覆盖，造成数据丢失。</p>
<p>Raft作者在发现这个问题之后，也给出了修复方法。修复方法很简单, 跟Raft的日志Commit条件类似：新任Leader必须在当前Term提交一条日志之后，才允许同步成员变更日志。也即Leader在当前Term还未提交日志之前，不允许同步成员变更日志。</p>
<p>按照这个修复方法，最简单的实现就是Leader上任后先提交一条no-op日志，然后再同步成员变更日志。这条no-op日志可以保证跟上一任Leader未提交的成员变更日志至少有一个节点交集，这样可以发现上一任Leader的日志是旧的，从而阻止上一任Leader重新选为Leader，进而阻止了脑裂的产生。</p>
<p>对应上面这个例子，就是L₁当选Leader后必须先提交一条no-op日志，然后才能开始同步Cᵥ和E，以便能发现L₂的日志是旧的，从而阻止L₂当选Leader。</p>
<p>另一种方法是使用Joint Consensus成员变更，没有这样的正确性问题。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paxos/" rel="tag">Paxos</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-算法题-易忘点"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/22/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%98%93%E5%BF%98%E7%82%B9/"
    >算法题-易忘点</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/22/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%98%93%E5%BF%98%E7%82%B9/" class="article-date">
  <time datetime="2022-01-22T15:46:54.000Z" itemprop="datePublished">2022-01-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="算法题-易忘点"><a href="#算法题-易忘点" class="headerlink" title="算法题-易忘点"></a>算法题-易忘点</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文收录我在刷算法题时常用常忘的一些知识点，包含但不限于算法套路、STL使用等。长期更新</p>
<h2 id="STL使用"><a href="#STL使用" class="headerlink" title="STL使用"></a>STL使用</h2><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p><img src="https://github.com/sWildGold/sWildGold.github.io/tree/master/source/_pic/c++stack.jpeg" alt="stack"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;std::string&gt; words;</span><br><span class="line">words.<span class="built_in">push</span>(std::<span class="built_in">string</span>(<span class="string">&quot;word&quot;</span>));</span><br><span class="line">std::string word = words.<span class="built_in">top</span>();</span><br><span class="line">words.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> size = words.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">bool</span> isEmpty = words.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure>

<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p><img src="https://github.com/sWildGold/sWildGold.github.io/tree/master/source/_pic/c++queue.jpeg" alt="queue"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;std::string&gt; words;</span><br><span class="line">words.<span class="built_in">push</span>(std::<span class="built_in">string</span>(<span class="string">&quot;word&quot;</span>));</span><br><span class="line">std::string word=words.<span class="built_in">front</span>();</span><br><span class="line">word=words.<span class="built_in">back</span>();</span><br><span class="line">word.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> size = words.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">bool</span> isEmpty = words.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="lower-bound-和-upper-bound"><a href="#lower-bound-和-upper-bound" class="headerlink" title="lower_bound 和 upper_bound"></a>lower_bound 和 upper_bound</h3><p>c++的algorithm头文件</p>
<ul>
<li>lower_bound:找到 <strong>大于等于</strong>目标元素 的下标。找到的是<strong>第一个</strong>可插入的位置，所以是lower。</li>
<li>upper_bound:找到 <strong>大于</strong>目标元素 的下标。找到的是<strong>最后一个</strong>可插入的位置，所以是upper。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());<span class="comment">//进行二分之前需要排序</span></span><br><span class="line"><span class="keyword">int</span> pos = <span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>()) - vec.<span class="built_in">begin</span>();  </span><br><span class="line"><span class="keyword">int</span> num = *<span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h3 id="二分查找的实现"><a href="#二分查找的实现" class="headerlink" title="二分查找的实现"></a>二分查找的实现</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/343138037">聊聊一看就会一写就跪的二分查找</a></p>
<p>此文将所有二分查找问题变种抽象为一个基本问题</p>
<blockquote>
<p>在一个左边全是 false 右边全是 true 的数组中，有且只有一个从 false 突变为 true 的点，二分查找其实就是要找到这个突变点。</p>
</blockquote>
<p><img src="../_pic/binarySearch1.png" alt="binarySearch1"></p>
<p><img src="../_pic/binarySearch2.png" alt="binarySearch2"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">BSearch</span><span class="params">(l, r <span class="keyword">int</span>, f func(<span class="keyword">int</span>) <span class="keyword">bool</span>)</span> <span class="keyword">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        <span class="comment">// 注意这里是为了避免溢出</span></span><br><span class="line">        m := l + (r - l) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> !<span class="built_in">f</span>(m) &#123;</span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = m</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心就是想办法把问题转化成基本问题中的布尔数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题: array 非严格递增，返回第一个大于 target 的元素下标。</span></span><br><span class="line"><span class="comment">// 补充: 如果查找不到合法结果，则返回 len(array) 即可。</span></span><br><span class="line"><span class="function">func <span class="title">FirstGtInAsc</span><span class="params">(array []string, target string)</span> <span class="keyword">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BSearch</span>(<span class="number">0</span>, <span class="built_in">len</span>(array), <span class="built_in">func</span>(x <span class="keyword">int</span>) <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[x] &gt; target</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题: array 非严格递增，返回第一个大于等于 target 的元素下标。</span></span><br><span class="line"><span class="comment">// 补充: 如果查找不到合法结果，则返回 len(array) 即可。</span></span><br><span class="line">func <span class="built_in">FirstGteInAsc</span>(array []string, target string) <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BSearch</span>(<span class="number">0</span>, <span class="built_in">len</span>(array), <span class="built_in">func</span>(x <span class="keyword">int</span>) <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[x] &gt;= target</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题: array 非严格递增，返回最后一个小于等于 target 的元素下标。</span></span><br><span class="line"><span class="comment">// 补充: 如果查找不到合法结果，则返回 -1 即可。</span></span><br><span class="line">func <span class="built_in">LastLtInAsc</span>(array []string, target string) <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BSearch</span>(<span class="number">0</span>, <span class="built_in">len</span>(array), <span class="built_in">func</span>(x <span class="keyword">int</span>) <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[x] &gt; target</span><br><span class="line">    &#125;) - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题: array 非严格递增，返回最后一个小于 target 的元素下标。</span></span><br><span class="line"><span class="comment">// 补充: 如果查找不到合法结果，则返回 -1 即可。</span></span><br><span class="line">func <span class="built_in">LastLteInAsc</span>(array []string, target string) <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BSearch</span>(<span class="number">0</span>, <span class="built_in">len</span>(array), <span class="built_in">func</span>(x <span class="keyword">int</span>) <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[x] &gt;= target</span><br><span class="line">    &#125;) - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题: array 非严格递减，返回第一个小于 target 的元素下标。</span></span><br><span class="line"><span class="comment">// 补充: 如果查找不到合法结果，则返回 len(array) 即可。</span></span><br><span class="line">func <span class="built_in">FirstLtInAsc</span>(array []string, target string) <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BSearch</span>(<span class="number">0</span>, <span class="built_in">len</span>(array), <span class="built_in">func</span>(x <span class="keyword">int</span>) <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[x] &lt; target</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题: array 非严格递减，返回第一个小于等于 target 的元素下标。</span></span><br><span class="line"><span class="comment">// 补充: 如果查找不到合法结果，则返回 len(array) 即可。</span></span><br><span class="line">func <span class="built_in">FirstLteInAsc</span>(array []string, target string) <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BSearch</span>(<span class="number">0</span>, <span class="built_in">len</span>(array), <span class="built_in">func</span>(x <span class="keyword">int</span>) <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[x] &lt;= target</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题: array 非严格递减，返回最后一个大于等于 target 的元素下标。</span></span><br><span class="line"><span class="comment">// 补充: 如果查找不到合法结果，则返回 -1 即可。</span></span><br><span class="line">func <span class="built_in">LastGtInAsc</span>(array []string, target string) <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BSearch</span>(<span class="number">0</span>, <span class="built_in">len</span>(array), <span class="built_in">func</span>(x <span class="keyword">int</span>) <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[x] &lt; target</span><br><span class="line">    &#125;) - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题: array 非严格递减，返回最后一个大于 target 的元素下标。</span></span><br><span class="line"><span class="comment">// 补充: 如果查找不到合法结果，则返回 -1 即可。</span></span><br><span class="line">func <span class="built_in">LastGteInAsc</span>(array []string, target string) <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BSearch</span>(<span class="number">0</span>, <span class="built_in">len</span>(array), <span class="built_in">func</span>(x <span class="keyword">int</span>) <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[x] &lt;= target</span><br><span class="line">    &#125;) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[r];</span><br><span class="line">        <span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomized_partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l; <span class="comment">// 随机选一个作为我们的主元</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[r], nums[i]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">randomized_quicksort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="built_in">randomized_partition</span>(nums, l, r);</span><br><span class="line">            <span class="built_in">randomized_quicksort</span>(nums, l, pos - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">randomized_quicksort</span>(nums, pos + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">randomized_quicksort</span>(nums, <span class="number">0</span>, (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98/" rel="tag">算法题</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-DDIA第七章-事务笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/22/DDIA%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BA%8B%E5%8A%A1%E7%AC%94%E8%AE%B0/"
    >DDIA第七章-事务笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/22/DDIA%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BA%8B%E5%8A%A1%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2022-01-22T14:46:54.000Z" itemprop="datePublished">2022-01-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="DDIA第七章-事务-笔记"><a href="#DDIA第七章-事务-笔记" class="headerlink" title="DDIA第七章-事务 笔记"></a>DDIA第七章-事务 笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文参考了</p>
<ul>
<li>《数据库系统概念-第七版》第17、18章</li>
<li><a target="_blank" rel="noopener" href="https://pingcap.com/zh/blog/take-you-through-the-isolation-level-of-tidb-1">事务前沿研究 | 隔离级别的追溯与究明，带你读懂 TiDB 的隔离级别（上篇）</a></li>
<li><a target="_blank" rel="noopener" href="https://pingcap.com/zh/blog/transaction-frontiers-research-article-talk4">事务前沿研究丨事务并发控制</a></li>
</ul>
<h2 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h2><ul>
<li>原子性（Atomicity）：一个事务的所有效果在数据库中要么全部反映出来，要么根本不反映；故障不能让数据库处于事务部分执行的状态。但原子性不能保证事务的过程是原子发生的，还要配合Isolation。</li>
<li>一致性（Consistency）：若数据库一开始是一致的，则事务执行后数据库仍处于一致性状态。这里的一致性是一种应用程序定义的状态正确性或不变性（invariants），例如，给账户打钱，两个账户最后的总金额应当不变。应用程序有责任正确地定义事务来保证一致性，这不是数据库可以保证的事情。(将C加入ACID只是为了让ACID听起来更顺口，当时并非觉得这是很重要的事情)</li>
<li>隔离性（Isolation）：保证并发执行的事务是相互隔离的，互相感受不到对方的存在。ACID中的I指可串行化，即最后的结果与串行执行完全相同（等价）。</li>
<li>持久性（Durability）：一旦事务提交，该事务的修改就不会丢失，即使出现系统故障。</li>
</ul>
<p>下面的内容都是关于Isolation的。</p>
<h2 id="竞态条件-race-condition"><a href="#竞态条件-race-condition" class="headerlink" title="竞态条件(race condition)"></a>竞态条件(race condition)</h2><ul>
<li>脏读/Dirty Reads：读到了其他事务未提交的写。Read Committed及以上隔离级别可以防止脏读。</li>
<li>脏写/Dirty Writes：写覆盖了其他事务未提交的写。所有隔离级别都防止脏写。</li>
<li>读倾斜（不可重复读）/Read skew (Nonrepeatable Reads)：在不同的时间点看到不同的值。快照隔离是最常用的防范手段。</li>
<li>更新丢失/Lost updates: 两个事务读-修改-写同一对象，导致其中一个覆盖另一个的写入。</li>
<li>写倾斜/Write skew: 一般化的更新丢失。两个事务查询相同的对象，根据返回结果作出一些决定，然后更新其中的一些对象（不同的事务可能更新不同的对象），导致其中一个事务做决定的前提条件发生变化。只有serializable isolation可以防止。</li>
<li>幻读/Phantom reads: DDIA 认为这是导致Write skew的根源.事务读取了某些符合查询条件的对象，同时另一事务执行写入，改变了先前的查询结果。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357735555">Phantom Read 是 Non-repeatable Read 的 predicate 的版本</a></li>
</ul>
<p>以上的概念貌似因为历史原因，盘根错节，特别复杂和混乱，这里的解释肯定也错误很多。看个大概就得了。<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903712368885768#heading-13">分布式事务中的一致性和隔离性</a></p>
<h2 id="两阶段加锁-two-phase-locking-2PL"><a href="#两阶段加锁-two-phase-locking-2PL" class="headerlink" title="两阶段加锁(two-phase locking, 2PL)"></a>两阶段加锁(two-phase locking, 2PL)</h2><ul>
<li>如果事务A已经读取了某个对象，此时事务B想要写入改对象，等A提交或终止。</li>
<li>如果事务A已经修改了某个对象，此时事务B想要读取该对象，等A提交或终止。</li>
</ul>
<h3 id="2PL的实现"><a href="#2PL的实现" class="headerlink" title="2PL的实现"></a>2PL的实现</h3><ul>
<li>如果事务要读取对象，必须获取共享锁。可以有多个事务同时获得共享锁，但如果独占锁已给出，则其他事务必须等待。</li>
<li>如果事务要修改对象，必须获取独占锁。获取独占锁之前不能有锁。也就是说，如果对象已被上锁，则修改事务必须等待。</li>
<li>如果事务先读取对象，再修改对象，需要将共享锁升级为独占锁。升级锁的流程等价于直接获得独占锁。</li>
<li>事务获得锁之后，一直持有锁直到事务结束。这也是名字’two-phase’的来源，在第一阶段（事务执行之前）获取锁，在第二阶段（事务结束时）释放锁。</li>
</ul>
<h3 id="谓词锁"><a href="#谓词锁" class="headerlink" title="谓词锁"></a>谓词锁</h3><p>serializable isolation需要防止幻读问题。因此2PL需要引入谓词锁。它的作用类似于之前描述的共享/独占锁，而区别在于，它并不属于某个特定的对象（如表的某一行），而是作用于满足某些搜索条件的所有查询对象。</p>
<p>谓词锁会限制如下访问：</p>
<ul>
<li>如果事务A想要读取某些满足匹配条件的对象，例如采用SELECT查询，它必须以共享模式获得查询条件的谓词锁。如果另一个事务B正持有任何一个匹配对象的互斥锁，那么A必须等到B释放锁之后才能继续执行查询。</li>
<li>如果事务A想要插入、更新或删除任何对象，则必须首先检查所有旧值和新值是否与现有的任何谓词锁匹配（即冲突）。如果事务B持有这样的谓词锁，那么A必须等到B完成后才能继续。</li>
</ul>
<h3 id="索引区间锁"><a href="#索引区间锁" class="headerlink" title="索引区间锁"></a>索引区间锁</h3><p>谓词锁性能不佳。索引区间锁是将谓词锁保护的对象扩大化，选一个合适的索引对其施加共享锁。虽然索引区间锁会锁住更大的范围，但是开销更低。</p>
<p>别人的笔记：<br><a target="_blank" rel="noopener" href="https://masutangu.com/2019/12/20/distributed-system-4/">漫谈分布式：事务和隔离性级别</a><br><a target="_blank" rel="noopener" href="https://masutangu.com/2019/12/22/distributed-system-5/">漫谈分布式：线性一致性与共识算法</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DDIA/" rel="tag">DDIA</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-DDIA第五章-数据复制笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/29/DDIA%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6%E7%AC%94%E8%AE%B0/"
    >DDIA第五章-数据复制笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/29/DDIA%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2021-11-29T14:50:39.000Z" itemprop="datePublished">2021-11-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="DDIA第五章-数据复制-笔记"><a href="#DDIA第五章-数据复制-笔记" class="headerlink" title="DDIA第五章-数据复制 笔记"></a>DDIA第五章-数据复制 笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多副本技术主要服务于以下目的：</p>
<blockquote>
<ul>
<li><p>高可用性：即使某台机器出现故障，系统也能正常运行</p>
</li>
<li><p>连接断开与容错：允许应用程序在出现网络中断时继续工作。</p>
</li>
<li><p>低延迟：将数据放置在距离用户较劲的地方，从而实现更快地交互。</p>
</li>
<li><p>可扩展性：采用多副本读取，大幅提高系统读操作的吞吐量。</p>
</li>
</ul>
</blockquote>
<p>本章主要讨论了三种多副本方案：主从复制、多主节点复制、无主节点复制。</p>
<p>本章主要讨论数据库实践中常用的、相对简单的复制技术，不涉及多副本一致性和共识。</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>只能在主节点写，可以在所有节点读。</p>
<p>同步/异步复制</p>
<blockquote>
<ul>
<li>同步复制：主节点等待确认其他从节点写入数据后才报告成功写入。</li>
<li>异步复制：主节点写入后即返回写入成功。</li>
</ul>
</blockquote>
<h3 id="复制日志的实现方式"><a href="#复制日志的实现方式" class="headerlink" title="复制日志的实现方式"></a>复制日志的实现方式</h3><h4 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h4><p>主节点将每个操作语句记录下来作为日志发给从节点。对于关系型数据库，就是发SQL。</p>
<p>不适用：</p>
<blockquote>
<ul>
<li>任何调用非确定性函数的语句：如NOW()获取当前时间，RAND()获取随机数，可能在不同的副本上产生不同的值。主节点可以将非确定性函数替换为执行后的结果。</li>
<li>语句中使用了自增列，或是依赖于数据库的现有数据（如UPDATE … WHERE &lt;某些条件&gt;），则所有副本必须按照完全相同的顺序执行。进而，如果有并发执行的事务，会有很大限制。</li>
<li>有副作用的语句（如，触发器、存储过程、用户定义的函数等），可能会在不同的副本上产生不同的副作用。</li>
</ul>
</blockquote>
<h4 id="基于write-ahead-log传输"><a href="#基于write-ahead-log传输" class="headerlink" title="基于write-ahead log传输"></a>基于write-ahead log传输</h4><p>不管是日志结构存储引擎（LSM-Trees，log本来就是主要存储方式）还是采用覆盖写磁盘的B-Trees（WAL），都会有一个追加写的log。可以将该log发给从节点来构建副本。</p>
<p>缺点是log描述的数据结果非常底层：一个WAL包含了哪些磁盘块多哪些字节发生改变。这使得复制方案与存储引擎紧密耦合，要求主从节点的软件版本一致。</p>
<h4 id="基于行的逻辑日志复制"><a href="#基于行的逻辑日志复制" class="headerlink" title="基于行的逻辑日志复制"></a>基于行的逻辑日志复制</h4><p>与WAL相对的，复制和存储引擎采取不同的日志格式，让复制和存储逻辑剥离。这种复制日志被称为逻辑日志，以区分物理存储引擎的数据表示。</p>
<p>对于关系数据库来说，逻辑日志通常是指一系列记录来描述数据表<strong>行级别</strong>的写请求。</p>
<blockquote>
<ul>
<li>对于行插入，逻辑日志包含所有相关列的新值。</li>
<li>对于行删除，逻辑日志里包含足够的信息来唯一标识已删除的行，通常是靠主键。</li>
<li>对于行更新，逻辑日志里包含足够的信息来唯一标识更新的行，以及所有列的新值。</li>
</ul>
</blockquote>
<h4 id="基于触发器的复制"><a href="#基于触发器的复制" class="headerlink" title="基于触发器的复制"></a>基于触发器的复制</h4><p>某些情况下，需要将复制控制交给应用程序层，如，只想复制数据的一部分，想从一种数据库复制到另一种数据库，需要订制、管理冲突解决逻辑。</p>
<p>触发器支持注册自己的应用层代码，使得当数据库系统发生数据更改（写事务）时自动执行自定义代码。</p>
<h2 id="复制滞后导致的三个问题"><a href="#复制滞后导致的三个问题" class="headerlink" title="复制滞后导致的三个问题"></a>复制滞后导致的三个问题</h2><p>异步复制会导致复制滞后，从而导致三个（本节主要介绍三个）问题：读自己的写、单调读、前缀一致读。</p>
<h3 id="读自己的写-Reading-Your-Own-Writes"><a href="#读自己的写-Reading-Your-Own-Writes" class="headerlink" title="读自己的写(Reading Your Own Writes)"></a>读自己的写(Reading Your Own Writes)</h3><p>问题描述：应用层将数据写入主节点，由于异步复制，数据未到某从节点，应用层从该从节点读数据时就读不到自己刚写的数据。</p>
<p>对于这种情况，需要“写后读一致性”（read-after-write consistency)，也称“读写一致性”(read-your-writes consistency)。该机制保证如果用户重新加载页面，他们总是能看到自己最近提交的更新，但对其他用户没有任何保证。</p>
<p>基于主从复制的系统的可行方案：</p>
<blockquote>
<ul>
<li>如果用户访问可能会被修改的内容，从主节点读取；否则，在从节点读取。这要求在查询之前就知道内容是否可能被修改。比如，用户的首页信息只能由所有者编辑，其他人无法编辑，因此可以制定规则：总是从主节点读取用户自己的首页信息数据。比如，跟踪最近更新的时间，如果更新后一分钟以内，则总是在主节点读取。</li>
<li>客户端记录最近更新的时间戳，并附在读请求里。如果某从节点不够新，就换另一个节点。</li>
<li>如果副本分布在多数据中心，则将请求路由到主节点所在的数据中心（因为这里的节点更快被同步）。</li>
</ul>
</blockquote>
<h3 id="单调读（Monotonic-Reads）"><a href="#单调读（Monotonic-Reads）" class="headerlink" title="单调读（Monotonic Reads）"></a>单调读（Monotonic Reads）</h3><p>问题描述：连续两次读，第二次读的落后于第一次读。单调读一致性保证不会出现这种情况。</p>
<p>实现单调读的一种方式，确保同一用户总是从固定的副本读取。</p>
<h3 id="前缀一致读（Consistent-Prefix-Reads）"><a href="#前缀一致读（Consistent-Prefix-Reads）" class="headerlink" title="前缀一致读（Consistent Prefix Reads）"></a>前缀一致读（Consistent Prefix Reads）</h3><p>对于一系列按照某个顺序发生的写请求，读取这些内容时也会按照当时写入的顺序。这是分片数据库出现的一个特殊问题。</p>
<p>一个解决方案是确保任何具有因果关系顺序的写入都交给一个分区来完成。</p>
<h2 id="多主节点复制"><a href="#多主节点复制" class="headerlink" title="多主节点复制"></a>多主节点复制</h2><p>多个主节点接受写入</p>
<p>适用场景</p>
<blockquote>
<ul>
<li>多数据中心:每个数据中心内，采用常规的主从复制方案；在数据中心之间，多个主节点相互进行数据多交换、更新。</li>
<li>离线客户端操作：离线状态下，本地设备相当于一个主节点数据库。在离线状态下的任何更改，会在下次上线后，与服务器和其他设备同步。从架构层面看，这相当于数据中心之间的多主复制，只不过是数据中心之间网络连接非常不可靠的极端情况。</li>
<li>协作编辑：多个用户同时编辑文档。当一个用户编辑时，所做的更改会立即应用到本地副本，然后异步复制到服务器以及编辑统一文档的其他用户。</li>
</ul>
</blockquote>
<h3 id="处理写冲突"><a href="#处理写冲突" class="headerlink" title="处理写冲突"></a>处理写冲突</h3><p>多主复制的最大问题就是可能发生写冲突，必须有解决冲突的方案。</p>
<p>收敛于一致状态：所有的复制模型至少应该确保数据在所有副本中最终状态是一致的。因此，数据库必须以一种收敛趋同的方式解决冲突。实现收敛的冲突解决有以下可能的方式：</p>
<blockquote>
<ul>
<li>给每个写入分配一个唯一的ID，制定规则选出胜利者，并丢弃其他写入。会造成数据丢失。</li>
<li>给每个副本分配一个唯一的ID，并制定规则，例如ID大的副本写入始终优先于ID小的副本。会造成数据丢失。</li>
<li>以某种方式将这些值合并在一起。</li>
<li>记录和保留冲突相关的所有信息，然后依靠应用层的逻辑，事后解决冲突。</li>
</ul>
</blockquote>
<h2 id="无主节点复制"><a href="#无主节点复制" class="headerlink" title="无主节点复制"></a>无主节点复制</h2><p>允许任何副本直接接受写请求。</p>
<h3 id="Quorum"><a href="#Quorum" class="headerlink" title="Quorum"></a>Quorum</h3><p>n个副本，写入需要w个节点确认，读取需要至少查询r个节点，如果 w+r&gt;n，则读取的节点中可以保证包含最新值。</p>
<h4 id="quorum的局限性"><a href="#quorum的局限性" class="headerlink" title="quorum的局限性"></a>quorum的局限性</h4><blockquote>
<ul>
<li>如果采用了sloppy quorum，则不能保证读到最新值。</li>
<li>如果两个写操作同时进行，无法明确先后顺序。需要合并写入并发。</li>
<li>如果写与读并发，写操作可能仅在部分副本完成，此时读到的是新值还是旧值存在不确定性。</li>
<li>如果某些副本上写成功，某些副本上写入失败，总的成功副本少于w，那些成功的副本不会回滚，后续的读操作可能会读到不该读到的新值。</li>
<li>如果具有新值的节点失效，且后续恢复时数据来自某旧值节点，则新值数量少于w，打破了w+r&gt;n。</li>
<li>即使一切工作正常，也会出现一些边界情况，详情见第9章。</li>
</ul>
</blockquote>
<p>quorum通常无法得到本章罗列的一致性保证，包括写后读、单调读、前缀一致读等。</p>
<h4 id="sloppy-quorum"><a href="#sloppy-quorum" class="headerlink" title="sloppy quorum"></a>sloppy quorum</h4><p>当出现网络问题时，无法满足w和r的数量。可以将写请求暂时放在不属于n集合的其他临时节点中，令写和读满足w和r。等网络问题解决，再将临时节点中的数据回传给原始节点。sloppy quorum是为了提高写入的可用性，但也意味着即使满足w+r&gt;n，也不能保证读取到新值，因为新值可能存在于临时节点，还没被回传过来。</p>
<h3 id="检测并发写（处理写冲突）"><a href="#检测并发写（处理写冲突）" class="headerlink" title="检测并发写（处理写冲突）"></a>检测并发写（处理写冲突）</h3><h4 id="最后写入者获胜（last-write-wins，LWW）"><a href="#最后写入者获胜（last-write-wins，LWW）" class="headerlink" title="最后写入者获胜（last write wins，LWW）"></a>最后写入者获胜（last write wins，LWW）</h4><p>为每个写请求附加一个时间戳，选择最新的时间戳，丢弃较早时间戳的写入。LWW会删除非并发写（因为时钟同步问题，第8章）。</p>
<h4 id="版本矢量"><a href="#版本矢量" class="headerlink" title="版本矢量"></a>版本矢量</h4><p>DDIA讲得太少了，有空补一下。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-DDIA第三章-数据存储与检索笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/29/DDIA%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2%E7%AC%94%E8%AE%B0/"
    >DDIA第三章-数据存储与检索笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/29/DDIA%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2021-11-29T14:49:52.000Z" itemprop="datePublished">2021-11-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="DDIA第三章-数据存储与检索-笔记"><a href="#DDIA第三章-数据存储与检索-笔记" class="headerlink" title="DDIA第三章-数据存储与检索 笔记"></a>DDIA第三章-数据存储与检索 笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开个DDIA的新坑。虽然DDIA笔记全网烂大街，但是自己敲出的好像更香一点，有侧重的记录也方便日后复习。从第三章开始，至少到第九章。三天一篇，不鸽！</p>
<h2 id="几种索引"><a href="#几种索引" class="headerlink" title="几种索引"></a>几种索引</h2><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>(key-value, 追加式日志)<br>内存中保存hash map，将每个键一一映射到数据文件中特定的字节偏移量。</p>
<p>将日志分解成段，当文件达到一定大小就关闭它，将后续写入到新的段文件。每个段有自己独立的hash map。查找时先找最新段的hash map，如果键不存在，检查第二新的段，以此类推。</p>
<p>可以在后台对这些段执行压缩。</p>
<p>值得注意的问题：</p>
<blockquote>
<ul>
<li><p>删除记录：在文件中追加一个特殊的删除记录(tombstone)。合并日志段时，一旦发现墓碑标记，则会丢弃这个已删除键的所有值。</p>
</li>
<li><p>崩溃恢复：崩溃后，内存中的hash map丢失。原则上可以通过从头读文件，重新构造hash map。优化方法是将每个段的hash map的快照存储在磁盘上。</p>
</li>
<li><p>并发控制：由于写入以严格的先后顺序追加到日志中，所以一般写线程只能有一个。追加式日志非原地更新，所以可以被多个线程同时读取。</p>
</li>
</ul>
</blockquote>
<p>追加式日志的优点：</p>
<blockquote>
<ul>
<li><p>追加和分段合并主要是顺序写，比随机写更好。</p>
</li>
<li><p>追加式文件的并发和崩溃恢复更加简单。例如，不必担心在重写值时发生崩溃的情况，留下一个包含部分旧值和部分新值混杂在一起的文件。</p>
</li>
<li><p>合并旧段可以避免磁盘空间碎片化的问题。</p>
</li>
</ul>
</blockquote>
<p>哈希索引的局限性：</p>
<blockquote>
<ul>
<li><p>哈希表必须全部放入内存。原则上可以在磁盘上维护哈希表，但哈希表包含大量随机访问I/O。</p>
</li>
<li><p>区域查询效率不高，只能采取逐个查找的方式查询每个键。</p>
</li>
</ul>
</blockquote>
<h3 id="SSTables和LSM-Tree"><a href="#SSTables和LSM-Tree" class="headerlink" title="SSTables和LSM-Tree"></a>SSTables和LSM-Tree</h3><p>SSTable: Sorted String Table,排序字符串表。要求段文件中的kv对按键排序。</p>
<p>相较哈希索引的日志段的优点：</p>
<blockquote>
<ul>
<li><p>合并段更加高效：merge sort。</p>
</li>
<li><p>不需要在内存中保存所有键的索引：因为是有序的。因此内存索引可以是稀疏的。</p>
</li>
<li><p>可以将多个记录压缩到一个块里，稀疏内存索引中的每个条目指向压缩块的开头。可以节省磁盘空间以及节约I/O带宽。</p>
</li>
</ul>
</blockquote>
<p>LSM-Tree: Log-Structured Merge-Tree，日志结构的合并树。</p>
<p>构建LSM-Tree的流程：</p>
<blockquote>
<ul>
<li><p>当写入记录时，将其添加到内存的平衡树(又称内存表，memtable，e.g. 红黑树、AVL树)中。</p>
</li>
<li><p>当内存表超限时，将其作为SSTable文件写入磁盘。在SSTable写磁盘时，写入可以继续添加一个新的内存表实例。</p>
</li>
<li><p>为了处理读请求，先在内存表中查找键，然后是最新的SSTable,次新的SSTable，直到找到目标(或为空)。</p>
</li>
<li><p>后台周期性地执行段合并与压缩。</p>
</li>
<li><p>如果数据库崩溃，内存表丢失。可以在磁盘上保留一个单独的追加式日志，作为内存表数据的备份.</p>
</li>
</ul>
</blockquote>
<p>LSM-Tree的优化：</p>
<blockquote>
<ul>
<li><p>查找数据库不存在的键时，需要把内存表和所有的SSTable全部查一遍。可以使用布隆过滤器（检索一个元素是否在集合中，如果过滤器说不在，那就一定不在，如果说在，也可能不在，重点是快）.</p>
</li>
<li><p>压缩合并的策略：大小分级(Size-tired compaction)和分层压缩(leveled compaction)。具体可以看这里：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/140325974">纯干货！深入探讨 LSM Compaction 机制</a></p>
<ul>
<li><p>Size-tired: 较新的和较小的SSTables被连续合并到较旧和较大的SSTables。</p>
</li>
<li><p>leveled: 键的范围分裂成多个更小的SSTables，旧数据被移动到单独的“层级”。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="B-Trees"><a href="#B-Trees" class="headerlink" title="B-Trees"></a>B-Trees</h3><p>略</p>
<h3 id="对比B-Trees和LSM-Trees"><a href="#对比B-Trees和LSM-Trees" class="headerlink" title="对比B-Trees和LSM-Trees"></a>对比B-Trees和LSM-Trees</h3><p>LSM-Trees的优点:</p>
<blockquote>
<ul>
<li><p>LSM-Trees通常能够承受比B-Trees更高的写入吞吐量，一是它们有时可能有较低的写放大，二是它们以顺序方式写入SSTables，而不是重写树中的多个页。</p>
</li>
<li><p>LSM-Trees可以支持更好地压缩，因此通常磁盘上的文件比B-Trees小很多。</p>
</li>
</ul>
</blockquote>
<p>LSM-Trees的缺点: </p>
<blockquote>
<ul>
<li><p>日志结构存储的缺点：压缩时可能干扰正在进行的读写操作。磁盘的并发资源和写入带宽。</p>
</li>
<li><p>日志结构的存储引擎可能在不同的段中具有相同键的多个副本。B-trees的每个键都唯一对应一个位置，对事务语义友好。</p>
</li>
</ul>
</blockquote>
<p>##列存</p>
<p>略（写了个寂寞）</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DDIA/" rel="tag">DDIA</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-hello-world"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/29/hello-world/"
    >Hello World</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/29/hello-world/" class="article-date">
  <time datetime="2021-11-29T12:34:43.208Z" itemprop="datePublished">2021-11-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2022
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>